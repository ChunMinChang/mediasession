<pre class="metadata">
Title: Media Session Standard
Group: WHATWG
H1: Media Session
Shortname: mediasession
Status: LS
No Editor: true
Logo: https://resources.whatwg.org/logo.svg
Abstract: This specification enables web developers to obtain different levels
Abstract: of platform media focus, customize available platform media controls,
Abstract: and access platform media keys such as hardware keys found on
Abstract: keyboards, headsets, remote controls, and software keys found in
Abstract: notification areas and on lock screens of mobile devices.
!Participate: <a href="https://github.com/whatwg/mediasession/issues/new">File an issue</a> (<a href="https://github.com/whatwg/mediasession/issues?state=open">open issues</a>)
!Participate: <a href="https://wiki.whatwg.org/wiki/IRC">IRC: #whatwg on Freenode</a>
!Version History: <a href="https://github.com/whatwg/mediasession/commits">https://github.com/whatwg/mediasession/commits</a>
Boilerplate: omit conformance
</pre>

<script src=https://resources.whatwg.org/file-issue.js async></script>

<pre class="anchors">
urlPrefix: https://html.spec.whatwg.org/multipage/; spec: HTML
    type: interface
        urlPrefix: dom.html
            text: Document
        urlPrefix: embedded-content.html
            text: HTMLMediaElement
        urlPrefix: webappapis.html
            text: EventHandler
    type: element
        urlPrefix: embedded-content.html
            text: video
            text: audio
    type: dfn
        urlPrefix: infrastructure.html
            text: case-sensitive; url: #case-sensitivity-and-string-comparison
            text: reflect
            text: limited to only known values
            text: remove an element from a document; url: #remove-an-element-from-a-document
        urlPrefix: embedded-content.html
            text: media element
            text: media element load algorithm
            text: potentially playing
            text: ended playback
            text: paused; url: #dom-media-paused
            text: internal pause steps
        urlPrefix: infrastructure.html
            text: enumerated attribute
        urlPrefix: browsers.html
            text: browsing context
            text: top-level browsing context; url: #top-level-browsing-context
        urlPrefix: webappapis.html
            text: API base URL
            text: entry settings object
            text: event handlers
            text: event handler event type
            text: event handler content attributes
            text: queue a task
            text: fire a simple event
            text: task
            text: task source
            text: DOM manipulation task source
    type: method
        urlPrefix: embedded-content.html
            text: play(); for: HTMLMediaElement; url: #dom-media-play
            text: pause(); for: HTMLMediaElement; url: #dom-media-pause
    type: attribute
        urlPrefix: embedded-content.html
            text: paused; for: HTMLMediaElement; url: #dom-media-paused
            text: readyState; for: HTMLMediaElement; url: #dom-media-readystate
            text: HAVE_FUTURE_DATA; for: HTMLMediaElement; url: #dom-media-have_future_data
            text: HAVE_ENOUGH_DATA; for: HTMLMediaElement; url: #dom-media-have_enough_data
            text: pause; url: #event-media-pause
            text: play; url: #event-media-play
urlPrefix: https://url.spec.whatwg.org/;
    type: dfn; urlPrefix: #concept-
        text: url parser
        text: event listener
urlPrefix: https://webaudio.github.io/web-audio-api/; spec: WEBAUDIO
    type: interface
        text: AudioContext
urlPrefix: https://dom.spec.whatwg.org/; spec: DOM
    type: interface; urlPrefix: #interface-
        text: EventTarget
        text: Event
urlPrefix: http://www.w3.org/TR/DOM-Level-3-Events-key/; spec: dom-level-3-events-key
    type: attribute; urlPrefix: #key-
        text: MediaPlayPause; url: MediaPlayPause
        text: MediaTrackPrevious; url: MediaTrackPrevious
        text: MediaTrackNext; url: MediaTrackNext
urlPrefix: http://www.w3.org/TR/page-visibility/; spec: PAGE-VISIBILITY
    type: attribute
        text: visibilitychange; url: #sec-visibilitychange-event
        text: visibilityState; url: #dom-document-visibilitystate
        text: visible; url: #pv-page-visible
        text: hidden; url: #pv-page-hidden
</pre>

<h2 id="introduction">Introduction</h2>

<em>This section is non-normative.</em>

Media is used extensively today on the web to play a variety of different types
of content. It is often used to play music, podcasts and radio content. At other
times media elements are used to provide background music, sound effects,
notification sounds and to render WebRTC media stream content.

When playing media on the web, developers are currently forced to adopt a single
default platform modality for playing all media content. On the other hand,
native applications can access much richer media integration options with an
underlying platform. On mobile devices, native application developers can
request many different forms of media integration with the platform to obtain
access to headphone buttons, lock screens and notification areas as needed. On
desktop devices, native applications have access to keyboard media key events.
Native application developers can specify the conditions in which media content
should pause or duck on audio interruptions (i.e. pause or lower the volume for
the duration of an interruption), continue playing out when application focus is
lost or the device screen is switched off and interface with internal and
external remote controllers.

This specification provides these platform media integration features for web
media. By allowing web developers to express the intended usage of their media
content, user agents can supply the most suitable platform-level interactions
for that content and enforce logical inter-operation behavior on the current
platform between any number of different sources of media.

This specification describes the mechanism that allows web developers to specify
the most appropriate category for their media content and for user agents to
then use these supplied hints to enforce how different sources of web media
should interact with each other, other native media content and the underlying
platform.

<h2 id="conformance">Conformance</h2>

All diagrams, examples, and notes in this specification are non-normative, as
are all sections explicitly marked non-normative. Everything else in this
specification is normative.

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD",
"SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this
document are to be interpreted as described in RFC 2119. For readability, these
words do not appear in all uppercase letters in this specification. [[!RFC2119]]

Requirements phrased in the imperative as part of algorithms (such as "strip any
leading space characters" or "return false and terminate these steps") are to be
interpreted with the meaning of the key word ("must", "should", "may", etc) used
in introducing the algorithm.

Conformance requirements phrased as algorithms or specific steps may be
implemented in any manner, so long as the end result is equivalent. (In
particular, the algorithms defined in this specification are intended to be easy
to follow, and not intended to be performant.)

User agents may impose implementation-specific limits on otherwise unconstrained
inputs, e.g. to prevent denial of service attacks, to guard against running out
of memory, or to work around platform-specific limitations.

When a method or an attribute is said to call another method or attribute, the
user agent must invoke its internal API for that attribute or method so that
e.g. the author can't change the behavior by overriding attributes or methods
with custom properties or functions in JavaScript.

Unless otherwise stated, string comparisons are done in a <a>case-sensitive</a>
manner.

<h2 id="dependencies">Dependencies</h2>

The IDL fragments in this specification must be interpreted as required for
conforming IDL fragments, as described in the Web IDL specification. [[!WEBIDL]]

<h2 id="media-sessions">Media sessions</h2>

A <dfn>media session</dfn> represents one or more <a>media elements</a> within
the same <a>top-level browsing context</a> that share the same <a>media session
category</a>. Each <a>media session</a> then defines the interactions of those
<a>media elements</a> with both the underlying platform and other <a>media
elements</a> belonging to other <a>media sessions</a> within the user agent.

A <a>media session</a> may have associated <dfn>media session metadata</dfn>
that <em>can</em> consist of <dfn lt="session title">title</dfn>,
<dfn>artist name</dfn>, <dfn>album name</dfn>, <dfn>artwork URL</dfn> and
<dfn>artwork resource</dfn>.

A <a>media session</a> has a <dfn>current media session type</dfn>. The <a
lt="media session category">possible media categories and their states</a> are
defined below.

A <a>media session</a> may provide access to <dfn lt="media remote
control">media remote controls</dfn> that can be used to respond to hardware or
software remote control events. Such events may be triggered by e.g. keyboard
media keys, headphone buttons, remote controller buttons or notification and
lock screen media buttons.

A <a>media element</a> may have a <dfn>current media session</dfn>, which is a
<a>media session</a>. When a <a>media element</a> is created the user agent must
set its <a>current media session</a> to the current <a>top-level browsing
context</a>'s <a>media session</a>.

The <dfn>participating media elements</dfn> of a <a>media session</a> are the
<a>media elements</a> whose <a>current media session</a> is that
<a>media session</a>. A <a>media session</a> must keep a list of <dfn>active
participating media elements</dfn> that consists of zero or more
<a>participating media elements</a>.

<h3 id="media-session-states">States</h3>

A <a>media session</a> has a <dfn>current state</dfn>, which describes its
current status with respect to any interaction with other <a>media sessions</a>.
The possible values are as follows:

<dl>
  <dt>
    <dfn lt="idle media session state"><code>IDLE</code></dfn>
  </dt>
  <dd>
    The <a>media session</a> does not have any platform-level media focus nor is
    it in a suspended state.
  </dd>
  <dt>
    <dfn lt="active media session state"><code>ACTIVE</code></dfn>
  </dt>
  <dd>
    The <a>media session</a> currently has platform-level media focus.
  </dd>
  <dt>
    <dfn lt="interrupted media session state"><code>INTERRUPTED</code></dfn>
  </dt>
  <dd>
    The <a>media session</a> is currently suspended from having platform-level
    media focus and its <a>active participating media elements</a> are either <a
    lt="pause">paused</a> or
    <a lt="duck">ducked</a> based on the <a>media session</a>'s <a>media session
    category</a> and pending completion of another <a>media session</a>'s media
    focus.
  </dd>
</dl>

When a new <a>media session</a> is created its <a>current state</a> must be
initially set to
<code><a lt="idle media session state">IDLE</a></code>.

When the <a>media session invocation algorithm</a> is run a <a>media
session</a>'s <a>current state</a> may be set from <code><a lt="idle media
session state">IDLE</a></code> to
<code><a lt="active media session state">ACTIVE</a></code>.

When the <a>media session interruption algorithm</a> is run a <a>media
session</a>'s <a>current state</a> may be set from
<code><a lt="active media session state">ACTIVE</a></code> to either <code><a
lt="idle media session state">IDLE</a></code> or <code><a lt="interrupted media
session state">INTERRUPTED</a></code> depending on its associated <a>media
session category</a>.

When the <a>media session continuation algorithm</a> is run a <a>media
session</a>'s <a>current state</a> may be set from <code><a lt="interrupted
media session state">INTERRUPTED</a></code>
to <code><a lt="active media session state">ACTIVE</a></code>.

When the <a>media session release algorithm</a> is run a <a>media session</a>'s
<a>current state</a>
may be set from either <code><a lt="active media session
state">ACTIVE</a></code> or <code><a lt="interrupted media session
state">INTERRUPTED</a></code> to
<code><a lt="idle media session state">IDLE</a></code>.

<h3 id="media-session-types">Types</h3>

A <dfn>media session category</dfn> is a keyword that maps to a well-defined
interaction state for a <a>media session</a> – called its <dfn>media session
type</dfn> – that user agents use to enforce platform-specific interaction and
interoperation between web media.

The following table lists the available <a>media session categories</a> keywords
and their corresponding <a>media session type</a> states — the keywords in the
left column map to the states in the cell in the second column on the same row
as the keyword. The attribute should be set based on the preferred definitions
in the table’s third and fourth columns.

<table id="valid-media-categories">
  <tr>
    <th>Category</th>
    <th>State</th>
    <th>Definition</th>
    <th>Examples</th>
  </tr>
  <tr>
    <td>
      &quot;<dfn lt="content attribute value"><code>content</code></dfn>&quot;
    </td>
    <td>
      <dfn lt="content media state">Content</dfn>
    </td>
    <td>
      <ul>
        <li>
          <a>Indefinitely pauses</a> all other <a lt="active participating media
          elements">active</a>
          <code><a lt="default media state">Default</a></code> and <code><a
          lt="content media state">Content</a></code> content when <a
          href="#activating-a-media-session">playback begins</a>.
        </li>
        <li>
          Displays lock-screen and notification area user interfaces when
          <a href="#activating-a-media-session">playback begins</a>.
        </li>
        <li>
          Reacts to changes in both hardware and software-based media key
          buttons when <a href="#activating-a-media-session">playback
          begins</a>.
        </li>
        <li>
          <a>Ducks</a> itself when <code><a lt="transient media
          state">Transient</a></code> content <a
          href="#interrupting-a-media-session">starts interrupting</a>.
          <a>Unducks</a>
          itself when <code><a lt="transient media state">Transient</a></code>
          content is <a>paused</a> or <a href="#releasing-a-media-session">ends
          playback</a>.
        </li>
        <li>
          <a>Pauses</a> itself when <code><a lt="transient solo media
          state">Transient Solo</a></code> content <a
          href="#interrupting-a-media-session">starts interrupting</a>.
          <a>Unpauses</a> itself when <code><a lt="transient solo media
          state">Transient Solo</a></code> content is <a>paused</a> or <a
          href="#releasing-a-media-session">ends playback</a>.
        </li>
        <li>
          Continues playing normally when <code><a lt="ambient media
          state">Ambient</a></code> content <a
          href="#interrupting-a-media-session">starts interrupting</a>.
        </li>
      </ul>
    </td>
    <td>
      Music, podcasts, radio streams.
    </td>
  </tr>
  <tr>
    <td>
      &quot;<dfn lt="transient attribute
      value"><code>transient</code></dfn>&quot;
    </td>
    <td>
      <dfn lt="transient media state">Transient</dfn>
    </td>
    <td>
      <ul>
        <li>
          <a>Ducks</a> all other <a lt="active participating media
          elements">active</a>
          <code><a lt="default media state">Default</a></code>
          and <code><a lt="content media state">Content</a></code> content when
          <a href="#activating-a-media-session">playback begins</a>.
          <a>Unducks</a> all other <a lt="interrupted media session
          state">interrupted</a> <code><a lt="default media
          state">Default</a></code> and <code><a lt="content media
          state">Content</a></code> content when <a>paused</a> or <a
          href="#releasing-a-media-session">playback ends</a>.
        </li>
        <li>
          Does not display lock-screen and notification area user interfaces
          when <a href="#activating-a-media-session">playback begins</a>.
        </li>
        <li>
          Does not react to changes in both hardware and software-based media
          key buttons when <a href="#activating-a-media-session">playback
          begins</a>.
        </li>
        <li>
          <a>Pauses</a> itself when <code><a lt="transient solo media
          state">Transient Solo</a></code> content <a
          href="#interrupting-a-media-session">starts interrupting</a>.
          <a>Unpauses</a> itself when <code><a lt="transient solo media
          state">Transient Solo</a></code> content is <a>paused</a> or <a
          href="#releasing-a-media-session">ends playback</a>.
        </li>
        <li>
          Continues playing normally when other <code><a lt="transient media
          state">Transient</a></code> or <code><a lt="ambient media
          state">Ambient</a></code> content <a
          href="#interrupting-a-media-session">starts interrupting</a>.
        </li>
      </ul>
    </td>
    <td>
      Notification sounds. Spoken driving directions where playback of music in
      the background is acceptable.
    </td>
  </tr>
  <tr>
    <td>
      &quot;<dfn lt="transient-solo attribute
      value"><code>transient-solo</code></dfn>&quot;
    </td>
    <td>
      <dfn lt="transient solo media state">Transient Solo</dfn>
    </td>
    <td>
      <ul>
        <li>
          <a>Pauses</a> all other <a lt="active participating media
          elements">active</a>
          <code><a lt="default media state">Default</a></code>,
          <code><a lt="content media state">Content</a></code>, <code><a
          lt="transient media state">Transient</a></code> and
          <code><a lt="transient solo media state">Transient Solo</a></code>
          content when <a href="#activating-a-media-session">playback
          begins</a>.
          <a>Unpauses</a> all <a lt="interrupted media session
          state">interrupted</a>
          <code><a lt="default media state">Default</a></code>, <code><a
          lt="content media state">Content</a></code>, <code><a lt="transient
          media state">Transient</a></code> and <code><a lt="transient solo
          media state">Transient Solo</a></code>
          content when <a>paused</a> or <a
          href="#releasing-a-media-session">playback ends</a>.
        </li>
        <li>
          Does not display lock-screen and notification area user interfaces
          when <a href="#activating-a-media-session">playback begins</a>.
        </li>
        <li>
          Does not react to changes in both hardware and software-based media
          key buttons when <a href="#activating-a-media-session">playback
          begins</a>.
        </li>
        <li>
          <a>Pauses</a> itself when other <code><a lt="transient solo media
          state">Transient Solo</a></code> content <a
          href="#interrupting-a-media-session">starts interrupting</a>.
          <a>Unpauses</a>
          itself when other <code><a lt="transient solo media state">Transient
          Solo</a></code> content is <a>paused</a> or <a
          href="#releasing-a-media-session">ends playback</a>.
        </li>
        <li>
          Continues playing normally when <code><a lt="ambient media
          state">Ambient</a></code> content <a
          href="#interrupting-a-media-session">starts interrupting</a>.
        </li>
      </ul>
    </td>
    <td>
      Playback of driving directions. Other spoken notifications.
    </td>
  </tr>
  <tr>
    <td>
      &quot;<dfn lt="ambient attribute value"><code>ambient</code></dfn>&quot;
    </td>
    <td>
      <dfn lt="ambient media state">Ambient</dfn>
    </td>
    <td>
      <ul>
        <li>
          Does not interact with any other <code><a lt="default media
          state">Default</a></code>,
          <code><a lt="content media state">Content</a></code>, <code><a
          lt="transient media state">Transient</a></code>,
          <code><a lt="transient solo media state">Transient Solo</a></code> or
          <code><a lt="ambient media state">Ambient</a></code> content during
          playback.
        </li>
        <li>
          Does not display lock-screen and notification area user interfaces
          when <a href="#activating-a-media-session">playback begins</a>.
        </li>
        <li>
          Does not react to changes in both hardware and software-based media
          key buttons when <a href="#activating-a-media-session">playback
          begins</a>.
        </li>
        <li>
          <a>Pauses</a> itself when its <a>top-level browsing context</a> is not
          visible (i.e. the page is placed in the background or the user agent
          is minimized or the screen is switched off). <a>Unpauses</a> itself
          when its
          <a>top-level browsing context</a> is at least partially visible on at
          least one screen again (i.e. the user agent is in the foreground and
          the page is focused again).
        </li>
      </ul>
    </td>
    <td>
      UI sounds. In-game sound effects and background music.
    </td>
  </tr>
  <tr>
    <td>
      &quot;<strong id="default-media-value"><code></code></strong>&quot; (empty
      string)
    </td>
    <td>
      <dfn lt="default media state">Default</dfn>
    </td>
    <td>
      <ul>
        <li>
          No explicit kind, or the kind of the media given is not recognized by
          the user agent.
        </li>
      </ul>
    </td>
    <td>
      Legacy media content
    </td>
  </tr>
</table>

<h3 id="media-session-resources">Resources</h3>

<p class=XXX>TODO: Add the required fetch steps for <a>artwork URL</a>.</p>

<h3 id="activating-a-media-session">Activating a media session</h3>

When the {{play()}} method on a <a>media element</a> is invoked and the <a>media
element</a>'s {{paused}} attribute is true and the <a>media element</a>'s
{{HTMLMediaElement/readyState}} attribute has the value {{HAVE_FUTURE_DATA}} or
{{HAVE_ENOUGH_DATA}}, then the user agent must run the <a>media session
invocation algorithm</a>, passing in the <a>media element</a> as
<var>current media element</var>. [[HTML]]

The <dfn>media session invocation algorithm</dfn> takes one argument,
<var>current media element</var>, and consists of the following steps:

<ol>
  <li>
    Let <var>media session</var> be the value of <var>current media
    element</var>'s <a>current media session</a>.
  </li>
  <li>
    If <var>current media element</var> is not currently in <var>media
    session</var>'s list of <a>active participating media elements</a> then
    append <var>current media element</var> to this list.
  </li>
  <li>
    If <var>media session</var> is <code><a lt="active media session
    state">ACTIVE</a></code> abort the remaining steps and return.
  </li>
  <li>
    Optionally, based on platform conventions, request the most appropriate
    platform-level media focus for <var>media session</var> based on its current
    <a>current media session type</a>.

    If this step is run and platform-level media focus can not be obtained for
    any reason then <a>pause</a> <var>current media element</var>, abort the
    remaining steps and return.
  </li>
  <li>
    Run these substeps:

    <dl class=switch>
      <dt>
        If <var>media session</var>'s <a>current media session type</a> is
        <code><a lt="content media state">Content</a></code>
      </dt>
      <dd>
        <ol>
          <li>
            Optionally, based on platform conventions, the user agent may show
            an ongoing media interface in the underlying platform's
            notifications area and/or show an ongoing media interface in the
            underlying platform's lock screen area for <var>media session</var>
            based on both the requested <a>media remote controls</a> and using
            any available <a>media session metadata</a>.
          </li>
          <li>
            Optionally, based on platform conventions, the user agent may allow
            hardware and/or software media keys to control playback of
            <var>media session</var>'s <a>active participating media
            elements</a> based on the requested <a>media remote controls</a>.
          </li>
        </ol>
      </dd>
      <dt>
        If <var>media session</var>'s <a>current media session type</a> is
        <code><a lt="transient media state">Transient</a></code> or <code><a
        lt="transient solo media state">Transient Solo</a></code>
      </dt>
      <dd class="note">
        The user agent should not provide user access to any hardware or
        software media keys and not display any ongoing media interface in the
        underlying platform's notifications area or show any ongoing media
        interface in the underlying platform's lock screen area for
        <code><a lt="transient media state">Transient</a></code> or
        <code><a lt="transient solo media state">Transient Solo</a></code>-based
        <a>media sessions</a>.
      </dd>
      <dt>
        If <var>media session</var>'s <a>current media session type</a> is
        <code><a lt="ambient media state">Ambient</a></code>
      </dt>
      <dd>
        If the <var>current media element</var>'s <a>top-level browsing
        context</a> is not at least partially visible on at least one screen
        then <a>pause</a>
        <var>current media element</var>, abort the remaining steps and return.

        <p class="note">
          The user agent should not provide user access to any hardware or
          software media keys and not display any ongoing media interface in the
          underlying platform's notifications area or show any ongoing media
          interface in the underlying platform's lock screen area for
          <code><a lt="ambient media state">Ambient</a></code>-based <a>media
          sessions</a>.
        </p>
      </dd>
    </dl>
  </li>
  <li>
    Set <var>media session</var>'s <a>current state</a> to
    <code><a lt="active media session state">ACTIVE</a></code>.
  </li>
</ol>

<h3 id="interrupting-a-media-session">Interrupting a media session</h3>

A <a>media session</a> may be interrupted at any time after its
<a>media session invocation algorithm</a> has been run. This typically occurs
when another application or <a>media session</a> requests and is granted
platform-level media focus.

Interruptions can be both transient or permanent. A transient interruption means
we can either choose to <a>duck</a> our media content and continue playing it
out at a reduced volume for the duration of the interruption; or <a>pause</a>
our media content for the duration of the interruption and then resume playback
when the interruption ends. A permanent interruption means we must <a
lt="indefinitely pause">pause our media content indefinitely</a>.

When a <a>media element</a> is to <dfn>pause</dfn> the user agent must run
<a>media element</a>'s <a>internal pause steps</a>.

When a <a>media element</a> is to <dfn>indefinitely pause</dfn> the user agent
must invoke its {{pause()}} method.

When the {{pause()}} method on a <a>media element</a> is invoked and the
<a>media element</a>'s {{paused}} attribute is initially false then the user
agent must remove this <a>media element</a> from its <a>current media
session</a>'s list of <a>active participating media elements</a>.

<p class="note">
  In effect, the different between running a <a>media element</a>'s <a>internal
  pause steps</a> and invoking a <a>media element</a>'s {{pause()}} method is
  whether we should keep a reference to that <a>media element</a> in its
  <a>current media session</a>'s list of <a>active participating media
  elements</a>.
</p>

After the {{pause()}} method on a <a>media element</a> has been invoked and that
<a>media element</a> has a <a>current media session type</a> set to
<code><a lt="transient media state">Transient</a></code> or <code><a
lt="transient solo media state">Transient Solo</a></code>, then the user agent
must run the <a>media session continuation algorithm</a> against all known
<a>media sessions</a>, passing in each <a>media session</a> as <var>incumbent
media session</var> and then, for the original <a lt="indefinitely
pause">indefinitely paused</a> <a>media session</a>, immediately run the
<a>media session release algorithm</a> passing in that <a>media element</a>'s
<a>current media session</a> as the only argument.

<div class="note">
  This prevents <code><a lt="transient media state">Transient</a></code> or
  <code><a lt="transient solo media state">Transient Solo</a></code>-based
  <a>media sessions</a> from indefinitely blocking the continuation of other
  <code><a lt="interrupted media session state">INTERRUPTED</a></code> <a>media
  sessions</a> when they are indefinitely paused.

  After we have completed this process, the original <code><a lt="transient
  media state">Transient</a></code> or
  <code><a lt="transient solo media state">Transient Solo</a></code>-based
  <a>media session</a> will have a <a>current state</a> of <code><a lt="idle
  media session state">IDLE</a></code> and all interrupted <a>media sessions</a>
  will have returned to a <a>current state</a> of <code><a lt="active media
  session state">ACTIVE</a></code>.
</div>

When a <a>media element</a> is to <dfn>unpause</dfn> the user agent must invoke
its {{play()}} method.

When a <a>media element</a> is to <dfn>duck</dfn> then the user agent must
ensure its output volume is lowered.

When a <a>media element</a> is to <dfn>unduck</dfn> then the user agent should
restore its output volume to the same level that was observed prior to the
original corresponding <a>duck</a> request.

When a <a>media session</a> receives a start-of-interruption notification from
the platform then the user agent must run the
<a>media session interruption algorithm</a> passing in the <a>media session</a>
as <var>interrupted media session</var>.

The <dfn>media session interruption algorithm</dfn> takes one argument,
<var>interrupted media session</var>, and consists of running the following
steps.

<ol>
  <li>
    If <var>interrupted media session</var>'s <a>current state</a> is not
    <code><a lt="active media session state">ACTIVE</a></code> abort the
    remaining steps and return.
  </li>
  <li>
    Let <var>interrupting media session category</var> be the <a>media session
    category</a> that triggered this interruption. If this interruption has no
    known
    <a>media session category</a>, let <var>interrupting media session
    category</var> be
    <code><a lt="default media state">Default</a></code>.
  </li>
  <li>
    Run these substeps:

    <dl class=switch>
      <dt>
        If <var>interrupting media session category</var> is <code><a
        lt="content media state">Content</a></code>
      </dt>
      <dd>
        <ol>
          <li>
            If <var>interrupted media session</var>'s <a>current media session
            type</a> is <code><a lt="default media state">Default</a></code>
            or <code><a lt="content media state">Content</a></code> then
            <a>indefinitely pause</a> all of <var>interrupted media
            session</var>'s <a>active participating media elements</a> and set
            <var>interrupted media session</var>'s <a>current state</a> to
            <code><a lt="idle media session state">IDLE</a></code>.

            <p class="note">
              This implies that the next time the <a>media session invocation
              algorithm</a>
              is run against a <a>media element</a> in <a>media session</a>
              that we will re-request media focus according to the steps defined
              in that algorithm.
            </p>
          </li>
          <li>
            Optionally, based on platform conventions, the user agent must
            remove any previously established ongoing media interface in the
            underlying platform's notifications area and any ongoing media
            interface in the underlying platform's lock screen area for
            <var>interrupted media session</var>, if any.
          </li>
          <li>
            Optionally, based on platform conventions, the user agent must
            prevent any hardware and/or software media keys from controlling
            playback of
            <var>interrupted media session</var>'s <a>active participating media
            elements</a>.
          </li>
        </ol>
      </dd>
      <dt>
        If <var>interrupting media session category</var> is <code><a
        lt="transient media state">Transient</a></code>
      </dt>
      <dd>
        <ol>
          <li>
            If <var>interrupted media session</var>'s <a>current media session
            type</a> is <code><a lt="default media state">Default</a></code>
            or <code><a lt="content media state">Content</a></code> then
            <a>duck</a>
            all of <var>interrupted media session</var>'s <a>active
            participating media elements</a> and set
            <var>interrupted media session</var>'s
            <a>current state</a> to <code><a lt="interrupted media session
            state">INTERRUPTED</a></code>.
            <p class="note">
              This implies that the next time the <a>media session continuation
              algorithm</a> is run that we will re-activate this <a>media
              session</a> according to the steps defined in that algorithm.
            </p>
          </li>
        </ol>
      </dd>
      <dt>
        If <var>interrupting media session category</var> is <code><a
        lt="transient solo media state">Transient Solo</a></code>
      </dt>
      <dd>
        <ol>
          <li>
            If <var>interrupted media session</var>'s <a>current media session
            type</a> is <code><a lt="default media state">Default</a></code>,
            <code><a lt="content media state">Content</a></code>, <code><a
            lt="transient media state">Transient</a></code> or <code><a
            lt="transient solo media state">Transient Solo</a></code> then
            <a>pause</a> all of
            <var>interrupted media session</var>'s
            <a>active participating media elements</a> and set <var>current
            media session</var>'s <a>current state</a> to
            <code><a lt="interrupted media session
            state">INTERRUPTED</a></code>.

            <div class="note">
              <p>
                This implies that the next time the <a>media session invocation
                algorithm</a>
                is run against a <a>media element</a> in <a>media session</a>
                that we will re-request media focus according to the steps
                defined in that algorithm.
              </p>

              <p>
                It also implies that the next time the <a>media session
                continuation algorithm</a> is run that we will re-activate this
                <a>media session</a> according to the steps defined in that
                algorithm.
              </p>
            </div>
          </li>
        </ol>
      </dd>
    </dl>
  </li>
</ol>

<p>&nbsp;</p>

When a <a>media session</a> receives an end-of-interruption notification from
the platform then the user agent must run the <a>media session continuation
algorithm</a> against all known <a>media sessions</a>, passing in each <a>media
session</a> as <var>incumbent media session</var>.

The <dfn>media session continuation algorithm</dfn> takes one argument,
<var>incumbent media session</var>, and consists of running the following steps.

<ol>
  <li>
    If <var>incumbent media session</var>'s <a>current state</a> is not
    <code><a lt="interrupted media session state">INTERRUPTED</a></code>
    then abort the remaining steps and return.
  </li>
  <li>
    Let <var>interrupting media session category</var> be the <a>media session
    category</a> that intially triggered this interruption. If this interruption
    has no known
    <a>media session category</a>, let <var>interrupting media session
    category</var> be
    <code><a lt="default media state">Default</a></code>.
  </li>
  <li>
    Run these substeps:

    <dl class=switch>
      <dt>
        If <var>interrupting media session category</var> is <code><a
        lt="transient media state">Transient</a></code>
      </dt>
      <dd>
        <ol>
          <li>
            If <var>incumbent media session</var>'s <a>current media session
            type</a> is <code><a lt="default media state">Default</a></code>
            or
            <code><a lt="content media state">Content</a></code>
            then <a>unduck</a> all of <var>incumbent media session</var>'s
            <a>active participating media elements</a>
            and set <var>incumbent media session</var>'s <a>current state</a> to
            <code><a lt="active media session state">ACTIVE</a></code>.
          </li>
        </ol>
      </dd>
      <dt>
        If <var>interrupting media session category</var> is <code><a
        lt="transient solo media state">Transient Solo</a></code>
      </dt>
      <dd>
        <ol>
          <li>
            If <var>incumbent media session</var>'s <a>current media session
            type</a> is <code><a lt="default media state">Default</a></code>,
            <code><a lt="content media state">Content</a></code>, <code><a
            lt="transient media state">Transient</a></code>, or
            <code><a lt="transient solo media state">Transient Solo</a></code>
            then <a>unpause</a> the
            <var>incumbent media session</var>'s <a>active participating media
            elements</a> and set <var>incumbent media session</var>'s <a>current
            state</a> to
            <code><a lt="active media session state">ACTIVE</a></code>.
          </li>
        </ol>
      </dd>
    </dl>
  </li>
</ol>

After a {{visibilitychange}} event [[PAGE-VISIBILITY]] has been fired at a
<a>top-level browsing context</a>, known as <var>the browsing context</var>, the
user agent must run the following steps:

<ol>
  <li>
    If {{visibilityState}} is not &quot;{{hidden}}&quot; or
    &quot;{{visible}}&quot; [[PAGE-VISIBILITY]] abort the remaining steps.
  </li>

  <li>
    For each <a>media session</a>, known as <var>s</var>, in <var>the browsing
    context</var> with an <a>current media session type</a> of <code><a
    lt="ambient media state">Ambient</a></code> run the following substeps:
    <ol>
      <li>
        If {{visibilityState}} is &quot;{{hidden}}&quot; [[PAGE-VISIBILITY]] and
        <var>s</var>'s <a>current state</a> is <code><a lt="active media session
        state">ACTIVE</a></code> then <a>pause</a> all of <var>s</var>'s
        <a>active participating media elements</a> and set <var>s</var>'s
        <a>current state</a> to <code><a lt="interrupted media session
        state">INTERRUPTED</a></code>, abort any remaining substeps and continue
        at the next available <var>s</var>.
      </li>
      <li>
        If {{visibilityState}} is &quot;{{visible}}&quot; [[PAGE-VISIBILITY]]
        and <var>s</var>'s <a>current state</a> is <code><a lt="interrupted
        media session state">INTERRUPTED</a></code> then <a>unpause</a> all of
        <var>s</var>'s <a>active participating media elements</a> and set
        <var>s</var>'s <a>current state</a> to <code><a lt="active media session
        state">ACTIVE</a></code>, abort any remaining substeps and continue at
        the next available <var>s</var>.
      </li>
    </ol>
  </li>
</ol>

<h3 id="releasing-a-media-session">Releasing a media session</h3>

When a <a>media element</a>'s <a lt="ended playback">playback has ended</a>, the
user agent must remove the <a>media element</a> from its <a>current media
session</a>'s <a>active participating media elements</a> and then run the
<a>media session release algorithm</a> passing in the
<a>media element</a>'s <a>current media session</a>, if any, as the only
argument.

Any time a <a>media element</a>'s <a lt="media element load algorithm">load
algorithm</a> is run by the user agent, it must remove the <a>media element</a>
from its <a>current media session</a>'s <a>active participating media
elements</a> and then also run the <a>media session release algorithm</a>
passing in the
<a>media element</a>'s <a>current media session</a>, if any, as the only
argument.

The <dfn>media session release algorithm</dfn> takes one argument,
<var>current media session</var>, and consists of running the following steps.

<ol>
  <li>
    If <var>current media session</var>'s <a>current state</a> is
    <code><a lt="idle media session state">IDLE</a></code> then abort the
    remaining steps and return.
  </li>
  <li>
    If <var>current media session</var> has one or more <a>active participating
    media elements</a> then abort the remaining steps and return.
  </li>
  <li>
    Optionally, based on platform conventions, the user agent must release any
    currently held platform media focus for <var>current media session</var>.
  </li>
  <li>
    Optionally, based on platform conventions, the user agent must remove any
    previously established ongoing media interface in the underlying platform's
    notifications area and any ongoing media interface in the underlying
    platform's lock screen area for
    <var>current media session</var>, if any.
  </li>
  <li>
    Optionally, based on platform conventions, the user agent must prevent any
    hardware and/or software media keys from controlling playback of
    <var>current media session</var>'s
    <a>active participating media elements</a>.

    <p class="note">
      If the algorithm reaches this step a <a>media session</a> can not have any
      <a>active participating media elements</a>.
    </p>
  </li>
  <li>
    Set <var>current media session</var>'s <a>current state</a> to
    <code><a lt="idle media session state">IDLE</a></code>.

    <p class="note">
      This implies that the next time the <a>media session invocation
      algorithm</a>
      is run against any <a>media element</a> in <a>current media session</a>
      that we will re-request media focus according to the steps defined in that
      algorithm.
    </p>
  </li>
</ol>

When a <a>media element</a> is <a lt="remove an element from a document">removed
from a <code>Document</code></a> and is not attached to another {{Document}},
remove the <a>media element</a> from its <a>current media session</a>'s
<a>active participating media elements</a> and then run the <a>media session
release algorithm</a>
passing in the
<a>media element</a>'s <a>current media session</a>, if any, as the only
argument.

<h2 id="api">API</h2>

<h3 id="the-mediasession-interface">The {{MediaSession}} interface</h3>

<a>Media sessions</a> implement the following interface:

<pre class="idl">
[Constructor(optional MediaSessionKind kind)]
interface MediaSession {
  readonly attribute MediaSessionKind kind;

  readonly attribute MediaRemoteControls? controls;

  void setMetadata(MediaMetadata metadata);

  void release();
};

enum MediaSessionKind {
  "content",
  "transient",
  "transient-solo",
  "ambient"
};

dictionary MediaMetadata {
  DOMString title = "";
  DOMString artist = "";
  DOMString album = "";
  USVString artwork;
};
</pre>

<h4 id="mediasession-garbage-collection">Garbage collection</h4>

A {{MediaSession}} object must not be garbage collected while its corresponding
<a>media session</a> is attached to at least one <a>participating media
element</a>.

Additionally, a {{MediaSession}} object must not be garbage collected while the
{{MediaSession}} object's child {{MediaRemoteControls}} object has an <a>event
listener</a> whose <b>type</b> is <code>previoustrack</code>,
<code>nexttrack</code>, <code>seekforward</code> or <code>seekbackward</code>.

<h4 id="mediasession-constructors">Constructors</h4>

<dl class=domintro>
  <dt>
    <code><var>session</var> = new <a constructor
    lt="MediaSession()">MediaSession</a>([<var>kind</var>])</code>
  </dt>
  <dd>
    Returns a new {{MediaSession}} object.
  </dd>
</dl>

The
<dfn constructor for=MediaSession>MediaSession(<var>kind</var>)</dfn>
constructor must create a new {{MediaSession}} object with its
{{MediaSession/kind}} attribute set to <var>kind</var> or &quot;<a lt="content
attribute value"><code>content</code></a>&quot if <var>kind</var> is empty, its
{{MediaSession/controls}} attribute set to a new {{MediaRemoteControls}} object
if its {{MediaSession/kind}} is &quot;<a lt="content attribute
value"><code>content</code></a>&quot or null otherwise, and then return it.

<h4 id="mediasession-object-members">Object members</h4>

<dl class=domintro>
  <dt>
    <code><var>session</var> . {{MediaSession/kind}}</code>
  </dt>
  <dd>
    Returns the DOMString value of the <a>current media session type</a> the
    <a>media session</a> represents.
  </dd>
</dl>

The <dfn attribute for="MediaSession" lt="kind"><code>kind</code></dfn>
attribute must return the DOMString value of the <a>current media session
type</a> of the <a>media session</a>.

<dl class=domintro>
  <dt>
    <code><var>session</var> . {{MediaSession/controls}}</code>
  </dt>
  <dd>
    Returns the {{MediaRemoteControls}} object assigned for the <a>media
    session</a>, if any.
  </dd>
</dl>

The <dfn attribute for="MediaSession" lt="controls"><code>controls</code></dfn>
attribute must return the {{MediaRemoteControls}} object that was assigned to
the <a>media session</a> when it was created. If {{MediaSession/kind}} is not
&quot;<a lt="content attribute value"><code>content</code></a>&quot then this
attribute should return null.

<dl class=domintro>
  <dt>
    <code><var>session</var> . {{MediaSession/setMetadata(metadata)}}</code>
  </dt>
  <dd>
    Provides the user agent with meta data to use when a <a>media session</a> is
    showing media control interfaces (e.g. in an OS-level notification area or
    on a lock screen).

    The <var>metadata</var> argument allows for setting a <a>media session</a>'s
    current meta data via object members. These are the object members that can
    be used:

    <dl>
      <dt>
        {{MediaMetadata/title}}
      </dt>
      <dd>
        The <a lt="session title">title</a> to display for the <a>media
        session</a>, if any.
      </dd>
      <dt>
        {{MediaMetadata/artist}}
      </dt>
      <dd>
        The <a>artist name</a> to display for the <a>media session</a>, if any.
      </dd>
      <dt>
        {{MediaMetadata/album}}
      </dt>
      <dd>
        The <a>album name</a> to display for the <a>media session</a>, if any.
      </dd>
      <dt>
        {{MediaMetadata/artwork}}
      </dt>
      <dd>
        The <a>artwork URL</a> for an image resource to display for the <a>media
        session</a>, if any.
      </dd>
    </dl>
  </dd>
</dl>

When the <dfn method for="MediaSession"><code>setMetadata(metadata)</code></dfn>
method is invoked, the user agent must run the following steps:

<ol>
  <li>
    Let <var>baseURL</var> be the <a>API base URL</a> specified by the <a>entry
    settings object</a>.
  </li>
  <li>
    Set <var>media session</var>'s <a lt="session title">title</a> to
    <var>metadata</var>'s <code>title</code>.
  </li>
  <li>
    Set <var>media session</var>'s <a>artist name</a> to <var>metadata</var>'s
    <code>artist</code>.
  </li>
  <li>
    Set <var>media session</var>'s <a>album name</a> to <var>metadata</var>'s
    <code>album</code>.
  </li>
  <li>
    If <var>metadata</var>'s <code>artwork</code> is present,
    <a lt="url parser">parse</a> it using <var>baseURL</var>, and if that does
    not return failure, set <var>media session</var>'s <a>artwork URL</a> to the
    return value. (Otherwise <a>artwork URL</a> is not set.)
  </li>
</ol>

<p class="XXX">TBD: When exactly should we fetch the <a>artwork URL</a>?</p>

<dl class=domintro>
  <dt>
    <code><var>session</var> . {{MediaSession/release()}}</code>
  </dt>
  <dd>
    Releases platform-level media focus, sets the <a>media session</a>'s
    <a>current state</a> to <code><a lt="idle media session
    state">IDLE</a></code> and applies any changes necessary to its
    <a>active participating media elements</a>.
  </dd>
</dl>

When the <dfn method for="MediaSession"
lt="release()"><code>release()</code></dfn> method is invoked, the user agent
must run the following steps:

<ol>
  <li>
    <a>Pause</a> each of <a>media session</a>'s <a>active participating media
    elements</a> and then remove each <a>active participating media element</a>
    from <a>media session</a>'s <a>active participating media elements</a>.
  </li>
  <li>
    Run the <a>media session release algorithm</a> passing in the
    <a>media session</a> as the only argument.
  </li>
</ol>

<h3 id="the-mediaremotecontrols-interface">The {{MediaRemoteControls}}
interface</h3>

<a>Media remote controls</a> implement the following interface:

<pre class="idl">
interface MediaRemoteControls : EventTarget {
  attribute boolean previousTrackEnabled;
  attribute boolean nextTrackEnabled;
  attribute boolean seekForwardEnabled;
  attribute boolean seekBackwardEnabled;

  // Event handlers
  attribute EventHandler onprevioustrack;
  attribute EventHandler onnexttrack;
  attribute EventHandler onseekforward;
  attribute EventHandler onseekbackward;
};
</pre>

<h4 id="mediaremotecontrols-object-members">Object members</h4>

<dl class=domintro>
  <dt>
    <code><var>controls</var> .
    {{MediaRemoteControls/previousTrackEnabled}}</code>
  </dt>
  <dd>
    Determines if a user can interact with a 'previous track' button.
  </dd>
  <dt>
    <code><var>controls</var> . {{MediaRemoteControls/nextTrackEnabled}}</code>
  </dt>
  <dd>
    Determines if a user can interact with a 'next track' button.
  </dd>
  <dt>
    <code><var>controls</var> .
    {{MediaRemoteControls/seekForwardEnabled}}</code>
  </dt>
  <dd>
    Determines if a user can interact with a 'seek forward' button.
  </dd>
  <dt>
    <code><var>controls</var> .
    {{MediaRemoteControls/seekBackwardEnabled}}</code>
  </dt>
  <dd>
    Determines if a user can interact with a 'seek backward' button.
  </dd>
</dl>

The <dfn attribute for="MediaRemoteControls"
lt="previousTrackEnabled"><code>previousTrackEnabled</code></dfn>
attribute is intended to provide a hint that the user agent should enable a
'previous track' button for users in all applicable hardware or software remote
control interfaces. By default, this attribute is false.

The <dfn attribute for="MediaRemoteControls"
lt="nextTrackEnabled"><code>nextTrackEnabled</code></dfn>
attribute is intended to provide a hint that the user agent should enable a
'next track' button for users in all applicable hardware or software remote
control interfaces. By default, this attribute is false.

The <dfn attribute for="MediaRemoteControls"
lt="seekBackwardEnabled"><code>seekBackwardEnabled</code></dfn>
attribute is intended to provide a hint that the user agent should enable a
'seek backward' button for users in all applicable hardware or software remote
control interfaces. By default, this attribute is false.

The <dfn attribute for="MediaRemoteControls"
lt="seekForwardEnabled"><code>seekForwardEnabled</code></dfn>
attribute is intended to provide a hint that the user agent should enable a
'seek forward' button for users in all applicable hardware or software remote
control interfaces. By default, this attribute is false.

<p class="note">
  While the attributes above can be set at any time they will only be read by
  the user agent during the <a>media session invocation algorithm</a> in order
  to correctly configure any connected remote control interfaces at the point
  they become <code><a lt="active media session state">ACTIVE</a></code>.
</p>

<p class="note">
  A user agent is not required to always implement each of these buttons
  separately in an ongoing notification area or lock screen interface. For
  example, if both {{MediaRemoteControls/nextTrackEnabled}} and
  {{MediaRemoteControls/seekForwardEnabled}} are set to true, the user agent may
  present a single unified button. When short-pressed this button may trigger a
  <a lt="event nexttrack"><code>nexttrack</code></a> event to be fired. When
  long-pressed this same button may trigger a <a lt="event
  seekforward"><code>seekforward</code></a> event to be fired. The exact
  notification and lock screen interfaces required to acheive this interaction
  are left up to implementers.
</p>

<h4 id="mediaremotecontrols-event-handlers">Event handlers</h4>

The following are the <a>event handlers</a> (and their corresponding <a>event
handler event types</a>) that must be supported, as IDL attributes, by all
objects implementing the {{MediaRemoteControls}} interface:

<table>
  <thead>
    <tr>
      <th>
        <a>Event handler</a>
      </th>
      <th>
        <a>Event handler event type</a>
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <dfn attribute
        for="MediaRemoteControls"><code>onprevioustrack</code></dfn>
      </td>
      <td>
        <code><a lt="event previoustrack">previoustrack</a></code>
      </td>
    </tr>
    <tr>
      <td>
        <dfn attribute for="MediaRemoteControls"><code>onnexttrack</code></dfn>
      </td>
      <td>
        <code><a lt="event nexttrack">nexttrack</a></code>
      </td>
    </tr>
    <tr>
      <td>
        <dfn attribute
        for="MediaRemoteControls"><code>onseekbackward</code></dfn>
      </td>
      <td>
        <code><a lt="event seekbackward">seekbackward</a></code>
      </td>
    </tr>
    <tr>
      <td>
        <dfn attribute
        for="MediaRemoteControls"><code>onseekforward</code></dfn>
      </td>
      <td>
        <code><a lt="event seekforward">seekforward</a></code>
      </td>
    </tr>
  </tbody>
</table>

The <a>task source</a> for the <a>tasks</a> listed in this section is the <a>DOM
manipulation task source</a>.

When the user presses the {{MediaPlayPause}} media key, or an equivalent key, on
any hardware or software interface (e.g. on a keyboard or OS-level button) then
the user agent must, for each <a>media session</a> known by the user agent, run
the following steps:

<ol>
  <li>
    Let <var>m</var> be the <a>media session</a>.
  </li>
  <li>
    If <var>m</var>'s <a>current media session type</a>
    is not <code><a lt="default media state">Default</a></code> or
    <code><a lt="content media state">Content</a></code>; or <var>m</var>'s
    <a>current state</a> is not
    <code><a lt="active media session state">ACTIVE</a></code> then abort these
    steps.
  </li>
  <li>
    For each <a>active participating media element</a> in <var>m</var>, called
    <var>active element</var>, run the following substeps:

    <ol>
      <li>
        If <var>active element</var> is <a>paused</a> then <a>unpause</a>
        <var>active element</var>. Otherwise, <a>pause</a> <var>active
        element</var>.
      </li>
    </ol>
  </li>
</ol>

When the user presses the {{MediaTrackPrevious}} media key, or an equivalent
key, on any hardware or software interface (e.g. on a keyboard or OS-level
button) then the user agent must, if
{{MediaRemoteControls/previousTrackEnabled}} is true, for each
<code><a lt="content media state">Content</a></code>-based <a>media session</a>
that is currently <code><a lt="active media session state">ACTIVE</a></code>,
<a>queue a task</a> to <a>fire a simple event</a> named <a lt="event
previoustrack"><code>previoustrack</code></a> at its child
{{MediaRemoteControls}} object.

When the user presses the {{MediaTrackNext}} media key, or an equivalent key, on
any hardware or software interface (e.g. on a keyboard or OS-level button) then
the user agent must, if {{MediaRemoteControls/nextTrackEnabled}} is true, for
each <code><a lt="content media state">Content</a></code>-based <a>media
session</a> that is currently <code><a lt="active media session
state">ACTIVE</a></code>, <a>queue a task</a> to
<a>fire a simple event</a> named <a lt="event
nexttrack"><code>nexttrack</code></a> at its child {{MediaRemoteControls}}
object.

When the user presses a 'seek backward' media key, or an equivalent key, on any
hardware or software interface (e.g. on a keyboard or OS-level button) then the
user agent must, if {{MediaRemoteControls/seekBackwardEnabled}} is true, for
each <code><a lt="content media state">Content</a></code>-based <a>media
session</a> that is currently <code><a lt="active media session
state">ACTIVE</a></code>, <a>queue a task</a> to
<a>fire a simple event</a> named <a lt="event
seekbackward"><code>seekbackward</code></a> at its child {{MediaRemoteControls}}
object.

When the user presses a 'seek forward' media key, or an equivalent key, on any
hardware or software interface (e.g. on a keyboard or OS-level button) then the
user agent must, if {{MediaRemoteControls/seekForwardEnabled}} is true, for each
<code><a lt="content media state">Content</a></code>-based <a>media session</a>
that is currently <code><a lt="active media session state">ACTIVE</a></code>,
<a>queue a task</a> to
<a>fire a simple event</a> named <a lt="event
seekforward"><code>seekforward</code></a> at its child {{MediaRemoteControls}}
object.

<h4 id="mediaremotecontrols-events-summary">Events summary</h4>

<em>This section is non-normative.</em>

The following events fire on <a>media remote controls</a> objects as part of the
processing model described above:

<table>
  <thead>
    <tr>
      <th>
        Event name
      </th>
      <th>
        Interface
      </th>
      <th>
        Fired when...
      </th>
      <th>
        Preconditions
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <dfn lt="event previoustrack"><code>previoustrack</code></dfn>
      </td>
      <td>
        {{Event}}
      </td>
      <td>
        The user presses the 'previous track' media key or button on any
        hardware or software media interface.
      </td>
      <td>
        <a>current media session type</a> is <code><a lt="content media
        state">Content</a></code>, <a>current state</a> is <code><a lt="active
        media session state">ACTIVE</a></code> and
        {{MediaRemoteControls/previousTrackEnabled}} is true.
      </td>
    </tr>
    <tr>
      <td>
        <dfn lt="event nexttrack"><code>nexttrack</code></dfn>
      </td>
      <td>
        {{Event}}
      </td>
      <td>
        The user presses the 'next track' media key or button on any hardware or
        software media interface.
      </td>
      <td>
        <a>current media session type</a> is <code><a lt="content media
        state">Content</a></code>, <a>current state</a> is <code><a lt="active
        media session state">ACTIVE</a></code> and
        {{MediaRemoteControls/nextTrackEnabled}} is true.
      </td>
    </tr>
    <tr>
      <td>
        <dfn lt="event seekbackward"><code>seekbackward</code></dfn>
      </td>
      <td>
        {{Event}}
      </td>
      <td>
        The user presses the 'seek backward' media key or button on any hardware
        or software media interface.
      </td>
      <td>
        <a>current media session type</a> is <code><a lt="content media
        state">Content</a></code>, <a>current state</a> is <code><a lt="active
        media session state">ACTIVE</a></code> and
        {{MediaRemoteControls/seekBackwardEnabled}} is true.
      </td>
    </tr>
    <tr>
      <td>
        <dfn lt="event seekforward"><code>seekforward</code></dfn>
      </td>
      <td>
        {{Event}}
      </td>
      <td>
        The user presses the 'seek forward' media key or button on any hardware
        or software media interface.
      </td>
      <td>
        <a>current media session type</a> is <code><a lt="content media
        state">Content</a></code>, <a>current state</a> is <code><a lt="active
        media session state">ACTIVE</a></code> and
        {{MediaRemoteControls/seekForwardEnabled}} is true.
      </td>
    </tr>
  </tbody>
</table>

<h2 id="assigning-a-media-session-to-media-elements">Assigning a media session
to media elements</h2>

In order to activate and use a <a>media session</a> it must be assigned to one
or more <a>media elements</a>. This section describes how a web developer can
assign a <a>media session</a> to a <a>media element</a> both declaratively and
programmatically.

<h3 id="extensions-to-the-htmlmediaelement-interface">Extensions to the
{{HTMLMediaElement}} interface</h3>

<pre class="idl">
partial interface HTMLMediaElement {
  // media session
  attribute DOMString kind;
  attribute MediaSession? session;
};
</pre>

<dl class=domintro>
  <dt>
    <code><var>media</var> . {{HTMLMediaElement/kind}}</code>
  </dt>
  <dd>
    Returns the category the given media falls into. The <a lt="media session
    categories">possible media categories</a> are defined above.
  </dd>
  <dt>
    <code><var>media</var> . {{HTMLMediaElement/session}}</code> [ = <code>
    session</code> ]
  </dt>
  <dd>
    Returns the <a>current media session</a> for the <a>media element</a>, if
    any; returns null otherwise.

    Can be set, to set an explicit {{MediaSession}}. Doing so updates the
    <a>media element</a>'s {{HTMLMediaElement/kind}} attribute.
  </dd>
</dl>

The <dfn attribute for="HTMLMediaElement" lt="kind"><code>kind</code></dfn> IDL
attribute is intended to provide a hint to the user agent about what the author
thinks will lead to the best user experience for media playback. The attribute
may be ignored altogether, for example based on explicit user preferences or
based on the capabilities of the underlying platform.

The <code>{{HTMLMediaElement/kind}}</code> attribute must
<a>reflect</a> the <code><a element>video</a></code> and <code><a
element>audio</a></code> element content attribute of the same name, <a>limited
to only known values</a>.

When a <a>media element</a>'s {{HTMLMediaElement/kind}} attribute is set,
changed, or removed then the user agent must run the <a>update the attached
media session algorithm</a>, passing in <a>media element</a> as the only
argument.

A <a>media element</a>'s <code>{{HTMLMediaElement/kind}}</code> attribute can be
changed at any time even once the media resource is being played; but it is only
read by the user agent at the time that it is set, changed or removed. Thus,
setting, changing or removing this attribute once the media element is
<a>potentially playing</a> does not dynamically change the <a>media session</a>
to which the <a>media element</a> belongs until the <a>media session invocation
algorithm</a> is subsequently re-run.

The <dfn attribute for="HTMLMediaElement"
lt="session"><code>session</code></dfn> attribute on a <a>media element</a>, on
getting, must return the element's <a>current media session</a>, if any, or null
otherwise. On setting, the user agent must run the following steps:

<ol>
  <li>
    Let <var>m</var> be the <a>media element</a> in question.
  </li>
  <li>
    Let <var>old media session</var> be <var>m</var>'s <a>current media
    session</a>, if it has one, and null otherwise.
  </li>
  <li>
    Let <var>new media session</var> be null.
  </li>
  <li>
    Let <var>m</var> have no <a>current media session</a>, if it currently has
    one.
  </li>
  <li>
    If the new value is null then set the element's {{HTMLMediaElement/kind}}
    attribute to the empty string. Otherwise, set element's
    {{HTMLMediaElement/kind}} attribute to the value of <a>current media
    session</a>'s {{MediaSession/kind}} attribute.
  </li>
  <li>
    Let <var>m</var>'s <a>current media session</a> be the new value or the
    <a>top-level browsing context</a>'s <a>media session</a> if the new value is
    null.
  </li>
  <li>
    Let <var>new media session</var> be <var>m</var>'s <a>current media
    session</a>.
  </li>
  <li>
    <var>Update media sessions</var>: If <var>old media session</var> and
    <var>new media session</var> are the same (whether both null or both the
    same <a>media session</a>) then abort these steps.
  </li>
  <li>
    If <var>m</var> is an <a>active participating media element</a> of <var>old
    media session</var> then <a>pause</a> <var>m</var>.
  </li>
  <li>
    Remove <var>m</var> from <var>old media session</var>'s <a>participating
    media elements</a>.
  </li>
  <li>
    If <var>old media session</var> is not null and no longer has one or more
    <a>active participating media elements</a>, then run the <a>media session
    release algorithm</a>, passing in <var>old media session</var> as the only
    argument.
  </li>
  <li>
    Add <var>m</var> to <var>new media session</var>'s <a>participating media
    elements</a>.
  </li>
</ol>

<h3 id="assigning-a-media-session-declaratively">Assigning a media session
declaratively</h3>

The <dfn lt="kind content attribute"><code>kind</code></dfn> content attribute
on <a>media elements</a> is an <a>enumerated attribute</a>
and must return the <a>media element</a>'s <a>media session category</a>, if it
has one, or the empty string otherwise.

When a <a>media element</a> is created with a {{HTMLMediaElement/kind}} content
attribute then the user agent must run the <a>update the attached media session
algorithm</a>, passing in <a>media element</a> as the only argument.

The <dfn>update the attached media session algorithm</dfn> takes one argument,
<var>current media element</var>, and consists of running the following steps:

<ol>
  <li>
    Let <var>media session type</var> be the <var>current media element</var>'s
    {{MediaSession/kind}} attribute's corresponding <a>media session type</a> as
    defined in the list of
    <a href="#valid-media-categories">possible media session categories</a>. If
    no known category match is found, let <var>media session type</var> be
    <code><a lt="default media state">Default</a></code>.
  </li>
  <li>
    If <var>media session type</var> is <code><a lt="default media
    state">Default</a></code> then let <var>media session</var> be the current
    <a>top-level browsing context</a>'s <a>media session</a> and set
    <var>current media element</var>'s <a>current media session</a> to the
    current
    <a>top-level browsing context</a>'s <a>media session</a>. Otherwise, if
    <var>current media element</var>'s <a>current media session type</a> is the
    same as <var>media session type</var> then let <var>media session</var> be
    <var>current media element</var>'s <a>current media session</a> object.
    Otherwise, let
    <var>media session</var> be a new {{MediaSession}} object and set <var>media
    session</var>'s <a>current media session type</a> to the value of
    <var>media session type</var>.
  </li>
  <li>
    If <var>media session type</var> is <code><a lt="default media
    state">Default</a></code> then set <var>current media element</var>'s
    {{HTMLMediaElement/session}} attribute to null, abort the remaining steps
    and return.
    <p class="note">
      <code><a lt="default media state">Default</a></code> <a>media sessions</a>
      do not expose a {{HTMLMediaElement/session}} attribute but still maintain
      an internal
      <a>current media session</a> reference.
    </p>
  </li>
</ol>

<h4 id="extensions-to-the-video-element">Extensions to the <code><a
element>video</a></code> element</h4>

<dl class="element">
  <dt>
    Additional content attributes:
  </dt>
  <dd>
    <a lt="kind content attribute"><code>kind</code></a> — The type of video
  </dd>
</dl>

<div class="example">
  A <code><a element>video</a></code> element's <code><a lt="kind content
  attribute">kind</a></code> content attribute can be declared as follows HTML:

  <pre class="lang-markup">
&lt;video src="short_ping.webm" kind="transient">
  </pre>
</div>

<h4 id="extensions-to-the-audio-element">Extensions to the <code><a
element>audio</a></code> element</h4>

<dl class="element">
  <dt>
    Additional content attributes:
  </dt>
  <dd>
    <a lt="kind content attribute"><code>kind</code></a> — The type of audio
  </dd>
</dl>

<div class="example">
  An <code><a element>audio</a></code> element's <code><a lt="kind content
  attribute">kind</a></code> content attribute can be declared as follows in
  HTML:

  <pre class="lang-markup">
&lt;audio src="track1.ogg" kind="content">
  </pre>
</div>

<h2 id="examples">Examples</h2>

<div class="example">
  As both <code><a element>audio</a></code> and <code><a
  element>video</a></code>
  elements implement the {{HTMLMediaElement}} interface, these element's
  {{HTMLMediaElement/kind}} attribute can be set via JavaScript:

  <pre class="lang-javascript">
var myAudio = document.createElement("audio");
myAudio.src = "music.mp3";

console.log(myAudio.session) // --> null
myAudio.kind = "content";
console.log(myAudio.session) // --> [object MediaSession]

myAudio.play(); // Go!
  </pre>

  A <a>media session</a> can also be assigned to one or more <code><a
  element>audio</a></code> and <code><a element>video</a></code>
  elements by setting their {{HTMLMediaElement/session}} attribute directly in
  JavaScript:

  <pre class="lang-javascript">
var myAudio = document.createElement("audio");
myAudio.src = "music.mp3";

var mySession = new MediaSession();

mySession.setMetadata({
  title: "Demo Track",
  artwork: "/resources/cover.png"
});

myAudio.session = mySession;
console.log(myAudio.kind) // --> "content"

myAudio.play(); // Go!
  </pre>
</div>

<div class="example">
  An {{AudioContext}} object [[!WEBAUDIO]] can be rendered via <code><a
  element>audio</a></code> or <code><a element>video</a></code>
  elements. As both <code><a element>audio</a></code> and <code><a
  element>video</a></code>
  elements implement the {{HTMLMediaElement}} interface, these element's
  {{HTMLMediaElement/kind}} attribute can be set via JavaScript:

  <pre class="lang-javascript">
var audioCtx = new AudioContext();
// ...
var destinationNode = audioCtx.createMediaStreamDestination();

var myAudio = document.createElement("audio");
myAudio.srcObject = destinationNode.stream;

console.log(myAudio.session) // --> null
myAudio.kind = "transient-solo";
console.log(myAudio.session) // --> [object MediaSession]

myAudio.play(); // Go!
  </pre>

  <p class="note">
    Web developers should ensure that, when an {{AudioContext}} object is
    attached to an <code><a element>audio</a></code> or <code><a
    element>video</a></code>
    element, that they apply subsequent {{pause}} and {{play}} events dispatched
    on that <code><a element>audio</a></code> or <code><a
    element>video</a></code>
    element to their {{AudioContext}} object appropriately.
  </p>
</div>
